<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Trading Journal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for dark mode */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #333; /* Darker track */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #555; /* Darker thumb */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #777; /* Lighter on hover */
        }
        body {
            font-family: 'Inter', sans-serif;
            /* Base dark mode styles */
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-200 */
        }
        /* Ensure table layout is fixed to prevent column width issues with long content */
        .table-fixed-layout {
            table-layout: fixed;
            width: 100%; /* Ensure table takes full width of container */
        }
         .table-fixed-layout th, .table-fixed-layout td {
            overflow-wrap: break-word; /* Break long words */
            word-wrap: break-word; /* Older browsers */
            hyphens: auto; /* Enable hyphenation */
        }
        /* Removed Chart Container adjustments */


        /* Styles for better mobile scroll performance */
        .overflow-x-container {
            -webkit-overflow-scrolling: touch; /* Improve scrolling on iOS Safari */
            transform: translateZ(0); /* Promote hardware acceleration */
        }

        /* Dark mode specific styles for elements */
        .dark-card {
            background-color: #2d3748; /* Tailwind gray-800 */
            color: #e2e8f0; /* Tailwind gray-200 */
        }

        .dark-filter-bg {
            background-color: #4a5568; /* Tailwind gray-700 */
        }

        .dark-input {
             background-color: #2d3748; /* Tailwind gray-800 */
             color: #e2e8f0; /* Tailwind gray-200 */
             border-color: #4a5568; /* Tailwind gray-700 */
        }
         .dark-input::placeholder {
             color: #a0aec0; /* Tailwind gray-500 */
         }
        .dark-input:focus {
             border-color: #667eea; /* Tailwind indigo-500 */
             box-shadow: 0 0 0 1px #667eea;
        }

         .dark-table-header {
             background-color: #4a5568; /* Tailwind gray-700 */
             color: #a0aec0; /* Tailwind gray-500 */
         }

         .dark-table-row {
             background-color: #2d3748; /* Tailwind gray-800 */
             color: #e2e8f0; /* Tailwind gray-200 */
         }
         .dark-table-row:hover {
             background-color: #4a5568; /* Tailwind gray-700 */
         }

         .dark-divide-gray-200 > * + * {
            border-color: #4a5568; /* Tailwind gray-700 */
         }

        /* Filter button active state */
        .filter-button.active {
            background-color: #4c51bf; /* Darker indigo */
            border-color: #434190;
        }
        /* Custom date input specific styling */
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1); /* Make calendar icon visible in dark mode */
        }

        /* Flex container for filter row items */
        .filter-row-items {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 1rem; /* Space between items */
            align-items: flex-end; /* Align items to the bottom */
            width: 100%; /* Take full width */
        }


    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 md:p-8">

        <header class="mb-4 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-indigo-400">My Trading Journal</h1>
        </header>

                <section id="trading-analysis" class="mb-10 p-6 rounded-lg shadow-lg dark-card">
            <div class="flex justify-between items-center mb-4">
                 <h2 class="text-2xl font-semibold text-gray-200">Performance Summary</h2>
            </div>

            <div class="mb-6">
                 <div class="flex justify-between text-sm font-medium text-gray-400 mb-1">
                     <p id="winRatePercentText" class="text-green-500">- Win %</p>
                     <p id="lossRatePercentText" class="text-red-500">- Loss %</p>
                </div>
                 <div id="winLossBarContainer" class="w-full flex rounded-md overflow-hidden" style="height: 20px;">
                      <div id="winBar" class="bg-green-500" style="width: 0%;"></div>
                      <div id="lossBar" class="bg-red-500" style="width: 0%;"></div>
                </div>
            </div>


                        <div id="analysisMetrics" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6">
                <div class="bg-gray-800 p-4 rounded-md text-center">
                    <p class="text-sm font-medium text-gray-400">Total Trades</p>
                    <p id="totalTrades" class="text-xl font-bold text-gray-200">-</p>
                </div>
                 <div class="bg-gray-800 p-4 rounded-md text-center">
                    <p class="text-sm font-medium text-green-500">Wins</p>
                    <p id="totalWins" class="text-xl font-bold text-green-400">-</p>
                </div>
                 <div class="bg-gray-800 p-4 rounded-md text-center">
                    <p class="text-sm font-medium text-red-500">Losses</p>
                    <p id="totalLosses" class="text-xl font-bold text-red-400">-</p>
                </div>
                             </div>

            </section>

        <section id="trading-performance" class="mb-10 p-6 rounded-lg shadow-lg dark-card">
            <h2 class="text-2xl font-semibold mb-6 text-gray-200">Trading Journal Data</h2>

            <div class="filters mb-6 p-4 rounded-md dark-filter-bg">
                                <div class="filter-row-items mb-4">
                     <span class="text-sm font-medium text-gray-300 self-center">Quick Dates:</span>
                     <button class="filter-button px-3 py-1 text-sm rounded border border-gray-600 bg-gray-700 text-gray-200 hover:bg-gray-600 active" data-time-period="all">All</button>
                     <button class="filter-button px-3 py-1 text-sm rounded border border-gray-600 bg-gray-700 text-gray-200 hover:bg-gray-600" data-time-period="90d">Last 90 days</button>
                     <button class="filter-button px-3 py-1 text-sm rounded border border-gray-600 bg-gray-700 text-gray-200 hover:bg-gray-600" data-time-period="30d">Last 30 days</button>
                     <button class="filter-button px-3 py-1 text-sm rounded border border-gray-600 bg-gray-700 text-gray-200 hover:bg-gray-600" data-time-period="7d">Last 7 days</button>
                </div>

                                <div class="filter-row-items mb-4 border-t border-gray-700 pt-4">
                    <span class="text-sm font-medium text-gray-300 self-center">Custom Dates:</span>
                    <div>
                        <label for="startDate" class="block text-sm font-medium text-gray-300 mb-1">Start Date:</label>
                        <input type="date" id="startDate" class="w-full md:w-auto mt-1 block px-3 py-2 rounded-md shadow-sm sm:text-sm dark-input">
                    </div>
                    <div>
                        <label for="endDate" class="block text-sm font-medium text-gray-300 mb-1">End Date:</label>
                        <input type="date" id="endDate" class="w-full md:w-auto mt-1 block px-3 py-2 rounded-md shadow-sm sm:text-sm dark-input">
                    </div>
                </div>


                                <div class="filter-row-items border-t border-gray-700 pt-4">
                     <span class="text-sm font-medium text-gray-300 self-center">Keyword Filters:</span>
                    <div>
                        <label for="coinFilter" class="block text-sm font-medium text-gray-300 mb-1">Coin Name:</label>
                        <input type="text" id="coinFilter" placeholder="e.g., BTC" class="w-full md:w-auto mt-1 block px-3 py-2 rounded-md shadow-sm sm:text-sm dark-input">
                    </div>
                    <div>
                        <label for="confluencesFilter" class="block text-sm font-medium text-gray-300 mb-1">Confluences:</label>
                        <input type="text" id="confluencesFilter" placeholder="e.g., RSI Divergence" class="w-full md:w-auto mt-1 block px-3 py-2 rounded-md shadow-sm sm:text-sm dark-input">
                    </div>

                                        <div class="w-full sm:w-auto flex-grow sm:flex-grow-0 self-end">
                        <a href="https://docs.google.com/forms/d/e/1FAIpQLSc3C614YyGITnD6D5JHJYxZh6PgQKP17HF5VlxMG6LHRiK0IA/viewform?usp=header"
                           target="_blank"
                           rel="noopener noreferrer"
                           class="inline-block w-full text-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-md shadow-lg transition duration-200 ease-in-out">
                           Log a New Trade
                        </a>
                    </div>

                    <button id="applyFiltersBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm w-full sm:w-auto">Apply Filters</button>
                    <button id="resetFiltersBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm w-full sm:w-auto">Reset ALL Filters</button>
                 </div>

            </div>

            <div id="loadingMessage" class="text-center py-4 text-gray-400">Loading trading data...</div>
            <div id="errorMessage" class="hidden text-center py-4 text-red-400 bg-red-900 border border-red-700 rounded-md"></div>

            <p class="text-sm text-gray-400 mb-2 md:hidden">Scroll table horizontally to see all columns &rarr;</p>
            <div class="overflow-x-auto rounded-lg shadow border border-gray-700 overflow-x-container">
                <table id="tradesTable" class="min-w-full divide-y dark-divide-gray-200 table-fixed-layout">
                    <thead class="dark-table-header">
                        <tr>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[100px]">Date</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[100px]">Coin Name</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[80px]">Result</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[150px]">Confluences</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[80px]">Time Frame</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[200px]">Remarks</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider min-w-[120px]">Chart Link</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider hidden">Timestamp</th>
                        </tr>
                    </thead>
                    <tbody id="tradesTableBody" class="dark-table-row divide-y dark-divide-gray-200">
                        </tbody>
                </table>
            </div>
            <p id="noResultsMessage" class="hidden text-center py-4 text-gray-400">No trades found matching your criteria.</p>
        </section>

    </div>

    <footer class="text-center py-8 mt-10 text-sm text-gray-500">
        <p>Trading data powered by Google Sheets.</p>
    </footer>

    <script>
        // --- CONFIGURATION ---
        // IMPORTANT: Replace with your published Google Sheet CSV URL
        const GOOGLE_SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ30TjoPmVjO7Do8PU8nSPvu8ld8UNbbgZPJBwfn8DdIoAcPi9DXUYEmsL1U7eN2Z0iJ3fU7c5Girxb/pub?gid=752099388&single=true&output=csv';


        // --- DOM ELEMENTS ---
        const tableBody = document.getElementById('tradesTableBody');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const noResultsMessage = document.getElementById('noResultsMessage');

        // Filter elements
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const coinFilterInput = document.getElementById('coinFilter');
        const confluencesFilterInput = document.getElementById('confluencesFilter');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const timePeriodButtons = document.querySelectorAll('.filter-button');

        // Analysis elements
        const totalTradesElement = document.getElementById('totalTrades');
        const totalWinsElement = document.getElementById('totalWins');
        const totalLossesElement = document.getElementById('totalLosses');
        // Removed the Win Rate element since the box was removed
        // const winRateElement = document.getElementById('winRate');

        // New elements for the Win/Loss bar visualization
        const winRatePercentText = document.getElementById('winRatePercentText');
        const lossRatePercentText = document.getElementById('lossRatePercentText');
        const winBar = document.getElementById('winBar');
        const lossBar = document.getElementById('lossBar');


        let allTrades = [];


        // --- DATA FETCHING AND PARSING ---
        async function fetchTrades() {
            loadingMessage.style.display = 'block';
            errorMessage.style.display = 'none';
            noResultsMessage.style.display = 'none';
            tableBody.innerHTML = '';

            if (GOOGLE_SHEET_CSV_URL.includes('YOUR_GOOGLE_SHEET_PUBLISHED_CSV_URL_HERE') || !GOOGLE_SHEET_CSV_URL) {
                showError('Error: Google Sheet CSV URL is not configured. Please update the GOOGLE_SHEET_CSV_URL variable in the script.');
                loadingMessage.style.display = 'none';
                return;
            }

            try {
                // Add cache-busting parameter
                const response = await fetch(`${GOOGLE_SHEET_CSV_URL}&timestamp=${new Date().getTime()}`);
                if (!response.ok) {
                     let errorText = `Network response was not ok: ${response.status}`;
                     try { errorText += ` - ${await response.text()}`; } catch(e) {}
                    throw new Error(errorText);
                }
                const csvData = await response.text();
                allTrades = parseCSV(csvData);

                if (allTrades.length === 0 && csvData.trim() !== "" && !csvData.toLowerCase().includes("error")) {
                     console.warn("CSV data was fetched but resulted in zero trades. Check console for parsing errors.");
                }

                applyTimePeriodFilter('all'); // Initial filter: Apply 'All' time period on load

            } catch (error) {
                console.error('Failed to fetch or parse trades:', error);
                showError(`Failed to load trades. Check the CSV URL and sheet permissions. Error: ${error.message}`);
            } finally {
                loadingMessage.style.display = 'none';
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length < 2) {
                console.log("CSV has no data rows or headers.");
                return [];
            }

            const headers = lines[0].split(',').map(header => header.trim().replace(/^"|"$/g, ''));
            const trades = [];

            const columnMappings = {
                timestamp: ['timestamp'],
                tradeDate: ['date', 'trade date'],
                coinName: ['coin name', 'coin'],
                result: ['result', 'outcome'],
                confluences: ['confluences'],
                timeFrame: ['time frame', 'timeframe', 'tf'],
                remarks: ['remarks', 'notes'],
                chartLink: ['chart link', 'link']
            };

            function findHeaderIndex(headerNames) {
                for (const name of headerNames) {
                    const index = headers.findIndex(h => h.toLowerCase() === name.toLowerCase());
                    if (index !== -1) return index;
                }
                 for (const name of headerNames) {
                     const index = headers.findIndex(h => h.toLowerCase().includes(name.toLowerCase()));
                     if (index !== -1) {
                          return index;
                     }
                 }
                return -1;
            }

            const timestampIdx = findHeaderIndex(columnMappings.timestamp);
            const dateIdx = findHeaderIndex(columnMappings.tradeDate);
            const coinNameIdx = findHeaderIndex(columnMappings.coinName);
            const resultIdx = findHeaderIndex(columnMappings.result);
            const confluencesIdx = findHeaderIndex(columnMappings.confluences);
            const timeFrameIdx = findHeaderIndex(columnMappings.timeFrame);
            const remarksIdx = findHeaderIndex(columnMappings.remarks);
            const chartLinkIdx = findHeaderIndex(columnMappings.chartLink);


             if (dateIdx === -1 || coinNameIdx === -1 || resultIdx === -1) {
                 showError("Essential columns (Date, Coin Name, Result) not found in CSV headers. Please check your Google Sheet columns.");
                 return [];
             }

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                // Robust CSV line parsing function
                function parseCSVLine(line) {
                    const values = [];
                    let inQuote = false;
                    let currentValue = '';

                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        const nextChar = line[j + 1];

                        if (char === '"') {
                            if (inQuote && nextChar === '"') {
                                // Escaped quote "" becomes a single "
                                currentValue += '"';
                                j++; // Skip the next quote
                            } else {
                                inQuote = !inQuote;
                            }
                        } else if (char === ',' && !inQuote) {
                            values.push(currentValue.trim());
                            currentValue = '';
                        } else {
                            currentValue += char;
                        }
                    }
                    values.push(currentValue.trim()); // Push the last value
                    return values;
                }

                const values = parseCSVLine(lines[i]);

                const maxIndex = Math.max(timestampIdx, dateIdx, coinNameIdx, resultIdx, confluencesIdx, timeFrameIdx, remarksIdx, chartLinkIdx);
                 if (maxIndex !== -1 && values.length < maxIndex + 1) {
                     // console.warn(`Skipping line ${i+1} due to insufficient columns.`);
                     continue;
                 }

                const trade = {
                    timestamp: timestampIdx !== -1 && values[timestampIdx] ? values[timestampIdx].trim() : '',
                    date: dateIdx !== -1 && values[dateIdx] ? values[dateIdx].trim() : (timestampIdx !== -1 && values[timestampIdx] ? values[timestampIdx].trim().split(' ')[0] : ''),
                    coinName: coinNameIdx !== -1 && values[coinNameIdx] ? values[coinNameIdx].trim() : 'N/A',
                    result: resultIdx !== -1 && values[resultIdx] ? values[resultIdx].trim() : 'N/A',
                    confluences: confluencesIdx !== -1 && values[confluencesIdx] ? values[confluencesIdx].trim() : 'N/A',
                    timeFrame: timeFrameIdx !== -1 && values[timeFrameIdx] ? values[timeFrameIdx].trim() : 'N/A',
                    remarks: remarksIdx !== -1 && values[remarksIdx] ? values[remarksIdx].trim() : 'N/A',
                    chartLink: chartLinkIdx !== -1 && values[chartLinkIdx] ? values[chartLinkIdx].trim() : 'N/A'
                };

                let tradeDateObj = null;
                // Attempt to parse date from timestamp first
                if (trade.timestamp) {
                    // Assuming MM/DD/YYYY HH:MM:SS or similar from Google Forms Timestamp
                    tradeDateObj = new Date(trade.timestamp);
                    if (isNaN(tradeDateObj.getTime())) {
                        // If timestamp parsing failed, try parsing just the date part
                        tradeDateObj = new Date(trade.date);
                    }
                } else if (trade.date && trade.date !== 'N/A') {
                    // If no timestamp, try parsing the date column
                    tradeDateObj = new Date(trade.date);
                }

                // Validate the parsed date object
                 if(trade.date !== 'N/A' && trade.coinName !== 'N/A' && trade.result !== 'N/A' && tradeDateObj && !isNaN(tradeDateObj.getTime())) {
                    // Normalize date to start of the day for easier comparison
                    trade.dateObject = new Date(tradeDateObj.getFullYear(), tradeDateObj.getMonth(), tradeDateObj.getDate());
                    trades.push(trade);
                 } else {
                     console.warn("Skipping trade due to missing essential data or invalid date:", trade, "Parsed Date:", tradeDateObj);
                 }
            }
            // Sort trades by date ascending
             trades.sort((a, b) => a.dateObject - b.dateObject);

            return trades;
        }

         // Helper function to format a Date object as YYYY-MM-DD for input values
         function formatDateForInput(date) {
             if (!date || isNaN(date.getTime())) return '';
             const year = date.getFullYear();
             const month = ('0' + (date.getMonth() + 1)).slice(-2); // Months are 0-indexed
             const day = ('0' + date.getDate()).slice(-2);
             return `${year}-${month}-${day}`;
         }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }


        // --- FILTERING LOGIC ---

        // This function sets the date inputs based on quick date buttons and updates button state
        function applyTimePeriodFilter(period) {
             const now = new Date();
             let startDate = null;
             let endDate = new Date(now); // End date is typically today for quick filters
             endDate.setHours(23, 59, 59, 999); // Set end date to end of the day

             if (period === '7d') {
                 startDate = new Date(now);
                 startDate.setDate(now.getDate() - 7);
                startDate.setHours(0, 0, 0, 0); // Set start date to beginning of the day
             } else if (period === '30d') {
                  startDate = new Date(now);
                 startDate.setDate(now.getDate() - 30);
                startDate.setHours(0, 0, 0, 0);
             } else if (period === '90d') {
                  startDate = new Date(now);
                 startDate.setDate(now.getDate() - 90);
                startDate.setHours(0, 0, 0, 0);
             }
             // 'all' means startDate remains null, endDate is end of today (or can be null too for true 'all')

             // Update custom date inputs based on the selected period
             startDateInput.value = startDate ? formatDateForInput(startDate) : '';
             endDateInput.value = endDate ? formatDateForInput(endDate) : '';


             // Update active button class
             timePeriodButtons.forEach(button => {
                 if (button.dataset.timePeriod === period) {
                     button.classList.add('active');
                     button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                     button.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                 } else {
                     button.classList.remove('active');
                     button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                     button.classList.add('bg-gray-700', 'hover:bg-gray-600');
                 }
             });

             applyFilters(); // Trigger filter application
        }


        // This function reads ALL filter inputs and applies the filter to allTrades
        function applyFilters() {
             let filteredTrades = allTrades;

             // 1. Apply Date Range Filter (Custom inputs take precedence)
             const customStartDateValue = startDateInput.value;
             const customEndDateValue = endDateInput.value;

             let filterStartDate = null;
             let filterEndDate = null;

             if (customStartDateValue) {
                  const date = new Date(customStartDateValue);
                  if (!isNaN(date.getTime())) {
                      filterStartDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                  }
             }

             if (customEndDateValue) {
                  const date = new Date(customEndDateValue);
                  if (!isNaN(date.getTime())) {
                      filterEndDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                      filterEndDate.setDate(filterEndDate.getDate() + 1); // Include the end day
                  }
             }

             // Filter by date range
             filteredTrades = filteredTrades.filter(trade => {
                  if (!trade.dateObject) return false; // Skip trades without a valid date

                  const tradeDate = trade.dateObject;

                  const isAfterStart = filterStartDate ? tradeDate >= filterStartDate : true; // If no start date, all trades are after
                  const isBeforeEnd = filterEndDate ? tradeDate < filterEndDate : true; // If no end date, all trades are before

                  return isAfterStart && isBeforeEnd;
             });


             // 2. Apply Keyword Filters to the date-filtered trades
            const coinQuery = coinFilterInput.value.toLowerCase().trim();
            const confluencesQuery = confluencesFilterInput.value.toLowerCase().trim();

            const finalFilteredTrades = filteredTrades.filter(trade => {
                const tradeCoinName = trade.coinName ? trade.coinName.toLowerCase() : '';
                const tradeConfluences = trade.confluences ? trade.confluences.toLowerCase() : '';

                const coinMatch = coinQuery === '' || tradeCoinName.includes(coinQuery);
                const confluencesMatch = confluencesQuery === '' || tradeConfluences.includes(confluencesQuery);

                return coinMatch && confluencesMatch;
            });


            renderTable(finalFilteredTrades);
            updateAnalysis(finalFilteredTrades);
        }

        function resetFilters() {
            // Clear keyword inputs
            coinFilterInput.value = '';
            confluencesFilterInput.value = '';
            // Clear custom date inputs
            startDateInput.value = '';
            endDateInput.value = '';

            // Reset time period filter to 'All' and re-apply all filtering
            applyTimePeriodFilter('all');
        }

        // --- ANALYSIS LOGIC ---
        function calculateMetrics(trades) {
            const total = trades.length;
            let wins = 0;
            let losses = 0;
            let breakEvens = 0;

            trades.forEach(trade => {
                const result = trade.result.toLowerCase();
                if (result === 'win' || result.includes('profit')) {
                    wins++;
                } else if (result === 'loss' || result.includes('loss')) {
                    losses++;
                } else {
                     breakEvens++;
                 }
            });

             // Calculate percentages out of *total* trades for the text display
            const winRatePercent = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
            const lossRatePercent = total > 0 ? ((losses / total) * 100).toFixed(1) : '0.0';

             // Calculate percentages out of *resolved* trades (Wins + Losses) for the bar width
             const resolvedTrades = wins + losses; // Only consider wins and losses for bar width proportion
             const winBarWidthPercent = resolvedTrades > 0 ? (wins / resolvedTrades) * 100 : 0;
             const lossBarWidthPercent = resolvedTrades > 0 ? (losses / resolvedTrades) * 100 : 0;


            return {
                total,
                wins,
                losses,
                breakEvens,
                winRatePercentTextValue: `${winRatePercent}% Win`, // Text above bar
                lossRatePercentTextValue: `${lossRatePercent}% Loss`, // Text above bar
                winBarWidth: winBarWidthPercent, // Width for win bar
                lossBarWidth: lossBarWidthPercent // Width for loss bar
            };
        }

        function updateAnalysis(trades) {
            const metrics = calculateMetrics(trades);

            totalTradesElement.textContent = metrics.total;
            totalWinsElement.textContent = metrics.wins;
            totalLossesElement.textContent = metrics.losses;
            // Removed update for the removed Win Rate box
            // winRateElement.textContent = metrics.winRate;

            // Update Win/Loss bar and text
            winRatePercentText.textContent = metrics.winRatePercentTextValue;
            lossRatePercentText.textContent = metrics.lossRatePercentTextValue;
            winBar.style.width = `${metrics.winBarWidth}%`;
            lossBar.style.width = `${metrics.lossBarWidth}%`;
        }


        // --- TABLE RENDERING ---
        function renderTable(trades) {
            tableBody.innerHTML = ''; // Clear existing rows
            noResultsMessage.style.display = trades.length === 0 ? 'block' : 'none';

            trades.forEach(trade => {
                const row = document.createElement('tr');
                row.classList.add('dark-table-row');

                // Format date for display
                const displayDate = trade.dateObject ? trade.dateObject.toLocaleDateString() : (trade.date !== 'N/A' ? trade.date : 'N/A');

                // Determine result text color
                let resultColorClass = 'text-gray-200'; // Default
                const resultLower = trade.result.toLowerCase();
                if (resultLower === 'win' || resultLower.includes('profit')) {
                    resultColorClass = 'text-green-400';
                } else if (resultLower === 'loss' || resultLower.includes('loss')) {
                    resultColorClass = 'text-red-400';
                }

                // Create Chart Link HTML
                const chartLinkHtml = trade.chartLink && trade.chartLink !== 'N/A' && trade.chartLink.startsWith('http')
                    ? `<a href="${trade.chartLink}" target="_blank" rel="noopener noreferrer" class="text-indigo-400 hover:underline">View Chart</a>`
                    : 'N/A';

                row.innerHTML = `
                    <td class="px-4 py-4 whitespace-nowrap text-sm font-medium text-gray-200">${displayDate}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-200">${trade.coinName}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-sm ${resultColorClass}">${trade.result}</td>
                    <td class="px-4 py-4 text-sm text-gray-200">${trade.confluences}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-200">${trade.timeFrame}</td>
                    <td class="px-4 py-4 text-sm text-gray-200">${trade.remarks}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-sm">${chartLinkHtml}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-500 hidden">${trade.timestamp}</td>
                `;
                tableBody.appendChild(row);
            });
        }


        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', fetchTrades);

        timePeriodButtons.forEach(button => {
            button.addEventListener('click', function() {
                applyTimePeriodFilter(this.dataset.timePeriod);
            });
        });

        // Apply filters when the button is clicked
        applyFiltersBtn.addEventListener('click', applyFilters);

        // Reset filters when the button is clicked
        resetFiltersBtn.addEventListener('click', resetFilters);

        // Also apply filters when custom date inputs change, but only if both are filled
        startDateInput.addEventListener('change', () => {
            // Deactivate quick buttons if custom date is manually set
            timePeriodButtons.forEach(button => {
                 button.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                 button.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });
            if (startDateInput.value && endDateInput.value) {
                applyFilters();
            }
        });

        endDateInput.addEventListener('change', () => {
            // Deactivate quick buttons if custom date is manually set
            timePeriodButtons.forEach(button => {
                 button.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                 button.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });
            if (startDateInput.value && endDateInput.value) {
                applyFilters();
            }
        });

        // Optionally apply keyword filters on input change (debounced for performance on large datasets)
        // coinFilterInput.addEventListener('input', applyFilters); // Uncomment and debounce if needed
        // confluencesFilterInput.addEventListener('input', applyFilters); // Uncomment and debounce if needed


    </script>
</body>
</html>
